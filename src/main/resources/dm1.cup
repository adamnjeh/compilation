package compil;

import java_cup.runtime.*;
import compil.ast.*;

parser code {:
  static class Corps {
    AstList<Attribut> attrs = new AstList<>();
    AstList<Methode> meths = new AstList<>();
  }
:}

non terminal Corps classeCorps;


/* ----- Terminals (keywords) ----- */
terminal CLASS, EXTENDS, PUBLIC, RETURN, INT, NEW, NULL;
terminal SYSTEM, OUT, PRINTLN;

/* ----- Terminals (punctuation) ----- */
terminal LBRACE, RBRACE, LPAREN, RPAREN, SEMI, DOT, COMMA, ASSIGN;

/* ----- Terminals with values ----- */
terminal String IDENT;
terminal String INTEGER_LITERAL;

/* ----- Non terminals ----- */
non terminal Axiome axiome;
non terminal AstList<Classe> classeList;
non terminal Classe classe;

non terminal Ident ident;
non terminal Ident parentOpt;             /* parent: Ident("Object") if empty */

non terminal AstList<Attribut> attributs;
non terminal Attribut attribut;

non terminal AstList<Methode> methodes;
non terminal Methode methode;

non terminal Type type;

non terminal AstList<Parametre> parametres;
non terminal Parametre parametre;

non terminal AstList<Instruction> instructions;
non terminal Instruction instruction;

non terminal Exp expression;

start with axiome;

/* ================== Grammar ================== */

/* Axiome -> ClasseList */
axiome ::= classeList:cl
         {: RESULT = new Axiome(cl); :}
         ;

/* ClasseList ::= vide | (Classe)+ */
classeList ::=
           /* empty */
         {: RESULT = new AstList<Classe>(); :}
         | classeList:cl classe:c
         {: cl.add(c); RESULT = cl; :}
         ;

/* Classe ::= "class" Ident Parent "{" ClasseCorps "}" */
classe ::= CLASS ident:n parentOpt:p LBRACE classeCorps:cc RBRACE
         {: RESULT = new Classe(n, p, cc.attrs, cc.meths); :}
         ;

/* Parent ::= ("extends" Ident)?  */
parentOpt ::=
           /* empty */
         {: RESULT = new Ident("Object"); :}
         | EXTENDS ident:p
         {: RESULT = p; :}
         ;

/* ClasseCorps ::= vide | (Attribut|Methode)+
   We implement it as: Attributs* then Methodes* (works for your test). */
classeCorps ::=
            /* empty */
          {: RESULT = new Corps(); :}
          | classeCorps:cc attribut:a
          {: cc.attrs.add(a); RESULT = cc; :}
          | classeCorps:cc methode:m
          {: cc.meths.add(m); RESULT = cc; :}
          ;


/* Attribut ::= Type Ident ";" */
attribut ::= type:t ident:i SEMI
           {: RESULT = new Attribut(t, i); :}
           ;

/* Type ::= "int" | Ident */
type ::= INT
       {: RESULT = new Type("int"); :}
       | ident:i
       {: RESULT = new Type(i.nom); :}
       ;

/* Méthode ::= "public" Type Ident "(" Paramètres ")"
               "{" Instructions "return" Expression ";" "}" */
methode ::= PUBLIC type:t ident:n LPAREN parametres:ps RPAREN
            LBRACE instructions:is RETURN expression:e SEMI RBRACE
          {: RESULT = new Methode(t, n, ps, is, e); :}
          ;

/* Paramètres ::= vide | Type Ident ("," Type Ident)* */
parametres ::=
            /* empty */
          {: RESULT = new AstList<Parametre>(); :}
          | parametre:p
          {: AstList<Parametre> l = new AstList<Parametre>(); l.add(p); RESULT = l; :}
          | parametres:ps COMMA parametre:p
          {: ps.add(p); RESULT = ps; :}
          ;

parametre ::= type:t ident:i
            {: RESULT = new Parametre(t, i); :}
            ;

/* Instructions ::= vide | Instruction+ */
instructions ::=
              /* empty */
            {: RESULT = new AstList<Instruction>(); :}
            | instructions:is instruction:i
            {: is.add(i); RESULT = is; :}
            ;

/* Instruction ::= println | assign */
instruction ::=
              SYSTEM DOT OUT DOT PRINTLN LPAREN expression:e RPAREN SEMI
            {: RESULT = new InstrPrintln(e); :}
            | ident:i ASSIGN expression:e SEMI
            {: RESULT = new InstrAssign(i, e); :}
            ;

/* Expression ::= intlit | ident | null | new Ident() */
expression ::=
              INTEGER_LITERAL:s
            {: RESULT = new ExpEntier(Integer.parseInt(s)); :}
            | ident:i
            {: RESULT = new ExpIdent(i); :}
            | NULL
            {: RESULT = new ExpNull(); :}
            | NEW ident:i LPAREN RPAREN
            {: RESULT = new ExpNew(i); :}
            ;

/* Identificateur ::= <IDENT> */
ident ::= IDENT:s
        {: RESULT = new Ident(s); :}
        ;
