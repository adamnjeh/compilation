package compil;

import java_cup.runtime.*;
import compil.ast.*;

parser code {:
  static class Corps {
    AstList<Attribut> attrs = new AstList<>();
    AstList<Methode> meths = new AstList<>();
  }
:}



terminal CLASS, EXTENDS, PUBLIC, RETURN, INT, NEW, NULL;
terminal SYSTEM, OUT, PRINTLN;

terminal LBRACE, RBRACE, LPAREN, RPAREN, SEMI, DOT, COMMA, ASSIGN;

terminal String IDENT;
terminal String INTEGER_LITERAL;

non terminal Axiome axiome;
non terminal AstList<Classe> classeList;
non terminal Classe classe;

non terminal Ident ident;
non terminal Ident parentOpt;             

non terminal Corps classeCorps;
non terminal AstList<Attribut> attributs;
non terminal Attribut attribut;

non terminal AstList<Methode> methodes;
non terminal Methode methode;

non terminal Type type;

non terminal AstList<Parametre> parametres;
non terminal Parametre parametre;

non terminal AstList<Instruction> instructions;
non terminal Instruction instruction;

non terminal Exp expression;

start with axiome;

axiome ::= classeList:cl
         {: RESULT = new Axiome(cl); :}
         ;

classeList ::=
           /* empty */
         {: RESULT = new AstList<Classe>(); :}
         | classeList:cl classe:c
         {: cl.add(c); RESULT = cl; :}
         ;

classe ::= CLASS ident:n parentOpt:p LBRACE classeCorps:cc RBRACE
         {: RESULT = new Classe(n, p, cc.attrs, cc.meths); :}
         ;

parentOpt ::=
           /* empty */
         {: RESULT = new Ident("Object"); :}
         | EXTENDS ident:p
         {: RESULT = p; :}
         ;

classeCorps ::=
            /* empty */
          {: RESULT = new Corps(); :}
          | classeCorps:cc attribut:a
          {: cc.attrs.add(a); RESULT = cc; :}
          | classeCorps:cc methode:m
          {: cc.meths.add(m); RESULT = cc; :}
          ;


attribut ::= type:t ident:i SEMI
           {: RESULT = new Attribut(t, i); :}
           ;

type ::= INT
       {: RESULT = new Type("int"); :}
       | ident:i
       {: RESULT = new Type(i.nom); :}
       ;

methode ::= PUBLIC type:t ident:n LPAREN parametres:ps RPAREN
            LBRACE instructions:is RETURN expression:e SEMI RBRACE
          {: RESULT = new Methode(t, n, ps, is, e); :}
          ;

parametres ::=
            /* empty */
          {: RESULT = new AstList<Parametre>(); :}
          | parametre:p
          {: AstList<Parametre> l = new AstList<Parametre>(); l.add(p); RESULT = l; :}
          | parametres:ps COMMA parametre:p
          {: ps.add(p); RESULT = ps; :}
          ;

parametre ::= type:t ident:i
            {: RESULT = new Parametre(t, i); :}
            ;

instructions ::=
              /* empty */
            {: RESULT = new AstList<Instruction>(); :}
            | instructions:is instruction:i
            {: is.add(i); RESULT = is; :}
            ;

instruction ::=
              SYSTEM DOT OUT DOT PRINTLN LPAREN expression:e RPAREN SEMI
            {: RESULT = new InstrPrintln(e); :}
            | ident:i ASSIGN expression:e SEMI
            {: RESULT = new InstrAssign(i, e); :}
            ;

expression ::=
              INTEGER_LITERAL:s
            {: RESULT = new ExpEntier(Integer.parseInt(s)); :}
            | ident:i
            {: RESULT = new ExpIdent(i); :}
            | NULL
            {: RESULT = new ExpNull(); :}
            | NEW ident:i LPAREN RPAREN
            {: RESULT = new ExpNew(i); :}
            ;

ident ::= IDENT:s
        {: RESULT = new Ident(s); :}
        ;
